#version 430 core

struct VoxelVertex
{
    // change alignment later for padding
    vec3 position;
    vec2 texCoord;
    vec3 normal;
    uint materialId;
    vec3 padding;
};

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) buffer voxels
{
    // 32 cube with 1 voxel of padding on each side
    uint[32][32][32] voxel;
};

layout(std430, binding = 1) buffer vertexOut
{
    VoxelVertex vertices[6144];
};

layout(binding = 2, offset = 0) uniform atomic_uint vertexCount;


void main()
{
    uint voxelType = voxel[gl_GlobalInvocationID.x][gl_GlobalInvocationID.y][gl_GlobalInvocationID.z];
    if (voxelType == 0)
    {
        return;
    }

    if (atomicCounter(vertexCount) >= 1024)
    {
        return;
    }

    uint firstIndex = atomicCounterIncrement(vertexCount) * 6;
    // voxel[gl_GlobalInvocationID.x][gl_GlobalInvocationID.y][gl_GlobalInvocationID.z] = atomicCounterIncrement(vertexCount);
    vertices[firstIndex] =      VoxelVertex(gl_GlobalInvocationID + uvec3(0, 0, 0), vec2(0.0, 0.0), vec3(0.0, 1.0, 0.0), voxelType, vec3(1.0));
    vertices[firstIndex + 1] =  VoxelVertex(gl_GlobalInvocationID + uvec3(1, 0, 0), vec2(1.0, 0.0), vec3(0.0, 1.0, 0.0), voxelType, vec3(1.0));
    vertices[firstIndex + 2] =  VoxelVertex(gl_GlobalInvocationID + uvec3(0, 0, 1), vec2(0.0, 1.0), vec3(0.0, 1.0, 0.0), voxelType, vec3(1.0));
    vertices[firstIndex + 3] =  VoxelVertex(gl_GlobalInvocationID + uvec3(1, 0, 1), vec2(1.0, 1.0), vec3(0.0, 1.0, 0.0), voxelType, vec3(1.0));
    vertices[firstIndex + 4] =  VoxelVertex(gl_GlobalInvocationID + uvec3(0, 0, 1), vec2(0.0, 1.0), vec3(0.0, 1.0, 0.0), voxelType, vec3(1.0));
    vertices[firstIndex + 5] =  VoxelVertex(gl_GlobalInvocationID + uvec3(1, 0, 0), vec2(1.0, 0.0), vec3(0.0, 1.0, 0.0), voxelType, vec3(1.0));
}