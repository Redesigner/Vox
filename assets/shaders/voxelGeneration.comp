#version 430 core

struct VoxelVertex
{
    // change alignment later for padding
    vec3 position;
    vec2 texCoord;
    vec3 normal;
    uint materialId;
    vec3 padding;
};

struct Quad
{
    uint x;
    uint y;
    uint w;
    uint h;
};

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) buffer voxels
{
    // 32 cube with 1 voxel of padding on each side
    uint[34][34][34] voxel;
};

layout(std430, binding = 1) buffer vertexOut
{
    VoxelVertex vertices[6144];
};

layout(binding = 2, offset = 0) uniform atomic_uint vertexCount;

const uint size = 32;

void main()
{
	bool visitedVoxels[size][size];

	for (int z = 0; z < size; ++z)
	{
		for (int x = 0; x < width; ++x)
		{
			// Find the first unexposed, visited voxel
			if (!visitedVoxels[x][z] && FaceExposedTop(x, y, z))
			{
				visitedVoxels[x][z] = true;

				// find the width of our quad first, by sweeping to the 'right'
				int quadRight = x + 1;
				for (; quadRight < width && !visitedVoxels[quadRight][z] && FaceExposedTop(quadRight, y, z); ++quadRight)
				{
					visitedVoxels[quadRight][z] = true;
				}

				// Place our cursor to the right of the last visited voxel,
				// this will wrap around if it's outside the width when our loop checks it

				int quadLower = z + 1;
				for (; quadLower < depth; ++quadLower)
				{
					bool rowInterrupted = false;
					for (int subX = x; subX < quadRight; ++subX)
					{
						if (visitedVoxels[subX][quadLower] || !FaceExposedTop(subX, y, quadLower))
						{
							rowInterrupted = true;
							break;
						}
					}

					if (rowInterrupted)
					{
						break;
					}
					
					// 'Visit' all the voxels in this row since it is part of our quad
					// but only after we're sure every one counted, otherwise, this shouldn't
					// be part of our quad
					for (int subX = x; subX < quadRight; ++subX)
					{
						visitedVoxels[subX][quadLower] = true;
					}
				}
				// either reached the end of our slice, or hit a wall
				// regardless, our quad is complete!
				quads.emplace_back(x, z, quadRight - x, quadLower - z);
				x = quadRight;
			}
		}
	}
}