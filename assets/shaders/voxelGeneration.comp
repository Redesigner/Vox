#version 430 core

struct VoxelVertex
{
    // change alignment later for padding
    vec3 position;
    vec2 texCoord;
    vec3 normal;
    uint materialId;
    vec3 padding;
};

struct Quad
{
    uint x;
    uint y;
    uint w;
    uint h;
};

layout(local_size_x = 32, local_size_y = 1) in;

layout(std430, binding = 0) buffer voxels
{
    // 32 cube with 1 voxel of padding on each side
    uint[34][34][34] voxel;
};

layout(std430, binding = 1) buffer vertexOut
{
    VoxelVertex vertices[6144];
};

layout(binding = 2, offset = 0) uniform atomic_uint vertexCount;

const uint size = 32;

void atomicInsertQuadTop(uint x, uint y, uint z, uint w, uint h)
{
	uvec3 quadOrigin = uvec3(x, y, z);
    uint firstIndex = atomicCounterIncrement(vertexCount) * 6;
    vertices[firstIndex] =      VoxelVertex(quadOrigin + uvec3(0, 0, 0), vec2(0.0, 0.0), vec3(0.0, 1.0, 0.0), 1, vec3(1.0));
    vertices[firstIndex + 1] =  VoxelVertex(quadOrigin + uvec3(w, 0, 0), vec2(  w,   h), vec3(0.0, 1.0, 0.0), 1, vec3(1.0));
    vertices[firstIndex + 2] =  VoxelVertex(quadOrigin + uvec3(0, 0, h), vec2(0.0,   h), vec3(0.0, 1.0, 0.0), 1, vec3(1.0));
    vertices[firstIndex + 3] =  VoxelVertex(quadOrigin + uvec3(w, 0, h), vec2(  w,   h), vec3(0.0, 1.0, 0.0), 1, vec3(1.0));
    vertices[firstIndex + 4] =  VoxelVertex(quadOrigin + uvec3(0, 0, h), vec2(0.0,   h), vec3(0.0, 1.0, 0.0), 1, vec3(1.0));
    vertices[firstIndex + 5] =  VoxelVertex(quadOrigin + uvec3(w, 0, 0), vec2(  w, 0.0), vec3(0.0, 1.0, 0.0), 1, vec3(1.0));
}

bool FaceExposedTop(uint x, uint y, uint z)
{
	return voxel[x + 1][y + 1][z + 1] == 1 && voxel[x + 1][y + 2][z + 1] == 0;
}

void main()
{
	bool visitedVoxels[size][size];

	for (int x = 0; x < size; ++x)
	{
		for (int y = 0; y < 32; ++y)
		{
			visitedVoxels[x][y] = false;
		}
	}

	int y = int(gl_GlobalInvocationID.x);

	for (int z = 0; z < size; ++z)
	{
		for (int x = 0; x < size; ++x)
		{
			// Find the first unexposed, visited voxel
			if (!visitedVoxels[x][z] && FaceExposedTop(x, y, z))
			{
				visitedVoxels[x][z] = true;

				// find the width of our quad first, by sweeping to the 'right'
				int quadRight = x + 1;
				for (; quadRight < size && !visitedVoxels[quadRight][z] && FaceExposedTop(quadRight, y, z); ++quadRight)
				{
					visitedVoxels[quadRight][z] = true;
				}

				// Place our cursor to the right of the last visited voxel,
				// this will wrap around if it's outside the width when our loop checks it

				int quadLower = z + 1;
				for (; quadLower < size; ++quadLower)
				{
					bool rowInterrupted = false;
					for (int subX = x; subX < quadRight; ++subX)
					{
						if (visitedVoxels[subX][quadLower] || !FaceExposedTop(subX, y, quadLower))
						{
							rowInterrupted = true;
							break;
						}
					}

					if (rowInterrupted)
					{
						break;
					}
					
					// 'Visit' all the voxels in this row since it is part of our quad
					// but only after we're sure every one counted, otherwise, this shouldn't
					// be part of our quad
					for (int subX = x; subX < quadRight; ++subX)
					{
						visitedVoxels[subX][quadLower] = true;
					}
				}
				// either reached the end of our slice, or hit a wall
				// regardless, our quad is complete!
				atomicInsertQuadTop(x, y, z, quadRight - x, quadLower - z);
				x = quadRight;
			}
		}
	}
}